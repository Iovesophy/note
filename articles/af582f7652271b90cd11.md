---
title: "Golang における配列とスライスのコピー時の違い"
emoji: "🎁"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Go"]
published: false
---

# Golang における配列とスライスのコピー時の違い

今回、私が配列とスライスを使用した時、そもそも配列とスライスの違いを意識せず使っていたため挙動を理解できていなかった経験からメモとして残しておく。

### では、仮にこういう問題を考えてみましょう

例えば、複数人で使うツール開発をしているとき、それぞれのユーザがそれぞれのデータを保持するために配列もしくはスライスを使う必要性があるとします。
ここで、それぞれのデータを共有して使いたいと考え、配列もしくはスライスを別の配列もしくはスライスにコピーして使用したいと考えました。
コピーしたデータを書き換えた際に、コピー元である他人のデータが勝手に書き変わったりそうでなかったりと不規則に影響が出てしまいました。果たしてそれは何故でしょうか。

# 実験

先程のシチュエーションを再現して考察してみましょう。

要素にする構造体
今回の説明で使用する構造体は以下の通りに定義されています。 配列(array)とスライス(slice),TestData型です。配列とスライスで比較しやすいように構造体にします。

```Go:struct
type TestDataI struct {
	slice []int
	array [4]int
}

type TestDataJ struct {
	slice []int
	array [4]int
}
```

ちなみにTestDataIとTestDataJで分けているのはIをオリジナル、Jをコピー先として使用するためです。

Arrayは固定長配列とも言いますが、固定するために配列の要素数をあらかじめ宣言しなければなりません。
今回は `[4]int` とint型要素数4の配列を宣言しています。
また、int型のArrayは宣言時にゼロパディングされます。

同様に、Sliceは可変長配列とも言いますが、Sliceの場合はあらかじめ要素数を宣言してはいけません。

# 初期化

配列やスライスを使うためにはデータの初期化処理が必要になります、
構造体で定義した配列とスライスを今回は `main()` で初期化することにします。

```Go:main()
func main() {
	var i TestDataI
	var j TestDataJ
	i.slice = []int{1, 2, 3, 4}
	i.array = [4]int{1, 2, 3, 4}
}
```

変数 `i` , `j` にそれぞれの構造体型を宣言します。
また、`i` にはあらかじめデータを入れておきます。

さて早速コピーしてみましょう。
Golang で配列やスライスをコピーするには=演算子を使う方法とcopy関数を使う方法などがありますが、今回は=演算子を使う方法で試してみます。

配列の場合

```Go:copy
	j.array = i.array
	fmt.Print("i:")
	fmt.Println(i.array)
	fmt.Print("j:")
	fmt.Println(j.array)
```

スライスの場合

```Go:copy
	j.slice = i.slice
	fmt.Print("i:")
	fmt.Println(i.slice)
	fmt.Print("j:")
	fmt.Println(j.slice)
```

実行結果

```
i:[1 2 3 4]
j:[1 2 3 4]
```
無事にコピーされたことを確認できましたね。

次にコピー元の `i` のデータを書き換えると何が起こるのでしょうか。
実際に書き換えを行ってみましょう。

配列の場合

```Go:rewrite
    fmt.Println("i.array[0] = 5")
	i.array[0] = 5
	fmt.Print("i:")
	fmt.Println(i.array)
    fmt.Print("j:")
	fmt.Println(j.array)
```

スライスの場合

```Go:rewrite
    fmt.Println("i.slice[0] = 5")
	i.slice[0] = 5
	fmt.Print("i:")
	fmt.Println(i.slice)
    fmt.Print("j:")
	fmt.Println(j.slice)
```

実行結果

```
i.array[0] = 5
i:[5 2 3 4]
j:[1 2 3 4]
i.slice[0] = 5
i:[5 2 3 4]
j:[5 2 3 4]
```
なんと実行結果を見て貰えば一目瞭然なのですが、 `i` と `j` で値が違いますね。

